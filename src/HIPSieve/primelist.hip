// !!! This is a file automatically generated by hipify!!!
#include "hip/hip_runtime.h"
/*

primelist.cu

source for the primeList class, which generates a list of 32 bit sieving primes
on the device

(c) 2016 Curtis Seizert <cseizert@gmail.com>

*/

#include "HIPSieve/host.hpp"
#include "HIPSieve/hipsieve.hpp"
#include "HIPSieve/global.cuh"
#include "HIPSieve/launch.cuh"
#include "HIPSieve/primelist.cuh"

#include <stdint.h>
#include <iostream>
#include <cmath>

uint32_t * PrimeList::getSievingPrimes(uint32_t maxPrime, uint32_t & primeListLength, bool silent)
{
 PrimeList primelist(maxPrime);

 primelist.allocate();
 primelist.iterSieve();
 primeListLength = (uint32_t)* primelist.kerneldata.h_count;
 if(!silent) std::cout << "List of sieving primes in " << primelist.timer.get_ms() << " ms." << std::endl;
 uint32_t * temp = primelist.d_primeList;
 primelist.d_primeList = NULL;

 return temp;
}

PrimeList::PrimeList(uint32_t maxPrime)
{
 this -> maxPrime = maxPrime;
 if(maxPrime < pow(2,22)) bigSieveKB = 256;
 if(maxPrime > pow(2,30)) bigSieveKB = 16384;
 if(maxPrime > pow(2,31)) bigSieveKB = 32768;

 blocks = (bigSieveKB << 13)/(32*PL_SIEVE_WORDS);
 threads = 512;

 hist_size_lg = blocks/512 + 1;
 piHighGuess = (int) (maxPrime/log(maxPrime))*(1+1.2762/log(maxPrime)); // this is an empirically derived formula to calculate a high bound for the prime counting function pi(x)

 PL_Max = ::min((uint32_t)65536, maxPrime);
}

void PrimeList::allocate()
{
 kerneldata.allocate();

 d_bigSieve =        safeCudaMalloc(d_bigSieve, bigSieveKB*256*sizeof(uint32_t));
 d_primeList =       safeCudaMalloc(d_primeList, piHighGuess*sizeof(uint32_t));
 d_histogram =       safeCudaMalloc(d_histogram, blocks*sizeof(uint32_t));
 d_histogram_lg =    safeCudaMalloc(d_histogram_lg, hist_size_lg*sizeof(uint32_t));

 hipMemset(d_histogram, 0, blocks*sizeof(uint32_t));
 hipMemset(d_histogram_lg, 0, hist_size_lg*sizeof(uint32_t));

 hipMemset(d_primeList, 0, piHighGuess*sizeof(uint32_t));
}

void PrimeList::iterSieve() // makes the list of primes on the device and then copies them back to the host
{
 timer.start();

 hipMemset(d_bigSieve, 0, bigSieveKB*256*sizeof(uint32_t));

hipLaunchKernelGGL(( device::firstPrimeList), dim3(1), dim3(256), 0, 0, d_primeList, kerneldata.d_count, 32768, PL_Max);
 hipDeviceSynchronize();
 primeListLength = (uint32_t)* kerneldata.h_count;
 if(maxPrime > PL_Max){

   for(uint64_t bottom = 65536; bottom < maxPrime; bottom += (bigSieveKB << 14)){

     hipMemset(d_histogram, 0, blocks*sizeof(uint32_t));
     hipMemset(d_histogram_lg, 0, hist_size_lg*sizeof(uint32_t));

     device::bigSieveSm<<<bigSieveKB/sieveKB, THREADS_PER_BLOCK, (sieveKB << 10)>>>
         (d_primeList, d_bigSieve, bottom, sieveKB, primeListLength);

     uint32_t * d_ptr = d_primeList + * kerneldata.h_count;

     hipDeviceSynchronize();

    hipLaunchKernelGGL(( device::makeHistogram_PLout), dim3(bigSieveKB), dim3(THREADS_PER_BLOCK), 0, 0, 
       d_bigSieve, d_histogram, (uint64_t)bottom, (uint64_t) maxPrime);
    hipLaunchKernelGGL(( device::exclusiveScan), dim3(hist_size_lg),dim3(threads),threads*sizeof(uint32_t), 0, 
       d_histogram, d_histogram_lg, blocks);
    hipLaunchKernelGGL(( device::exclusiveScan), dim3(1),dim3(hist_size_lg),hist_size_lg*sizeof(uint32_t), 0, 
       d_histogram_lg, kerneldata.d_count, hist_size_lg);
    hipLaunchKernelGGL(( device::increment), dim3(hist_size_lg),dim3(threads),threads*sizeof(uint32_t), 0, 
       d_histogram, d_histogram_lg, blocks);
    hipLaunchKernelGGL(( device::makePrimeList_PLout), dim3(bigSieveKB), dim3(THREADS_PER_BLOCK), 0, 0, 
       d_ptr, d_histogram, d_bigSieve, bottom, maxPrime);
     hipDeviceSynchronize();
   }
 }
 timer.stop();
}

PrimeList::~PrimeList()
{
 kerneldata.deallocate();
 hipFree(d_bigSieve);
 hipFree(d_histogram);
 hipFree(d_histogram_lg);
}
